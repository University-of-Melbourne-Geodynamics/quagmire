<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>quagmire API documentation</title>
<meta name="description" content="&lt;img src=&#34;https://raw.githubusercontent.com/underworldcode/quagmire/dev/docs/images/AusFlow.png&#34; style=&#34;display: block; margin: 0 auto&#34;&gt; â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>quagmire</code></h1>
</header>
<section id="section-intro">
<p><img src="https://raw.githubusercontent.com/underworldcode/quagmire/dev/docs/images/AusFlow.png" style="display: block; margin: 0 auto"></p>
<p><strong>Quagmire is a Python surface process framework for building erosion and deposition models on highly parallel, decomposed structured and unstructured meshes.</strong></p>
<p>Quagmire is structured into three major tiers that inherit methods and attributes from different classes:</p>
<p><img src="https://raw.githubusercontent.com/underworldcode/quagmire/dev/docs/images/quagmire-flowchart.png" style="width: 321px; float:right"></p>
<ol>
<li><code>SurfaceProcessMesh</code><ul>
<li>Calculate erosion-deposition rates</li>
<li>Landscape analysis</li>
<li>Long range flow models</li>
</ul>
</li>
<li><code>TopoMesh</code><ul>
<li>Assemble downhill connectivity matrix</li>
<li>Calculate upstream area</li>
<li>Compute slope</li>
<li>Identify flat spots, low points, high points.</li>
</ul>
</li>
<li><code>FlatMesh</code><ul>
<li>calculating spatial derivatives</li>
<li>identifying node neighbour relationships</li>
<li>interpolation / extrapolation</li>
<li>smoothing operators</li>
<li>importing and saving mesh information</li>
</ul>
</li>
</ol>
<p>The <code>quagmire.surfmesh.surfmesh.SurfMesh</code> class (1) inherits from
the <code><a title="quagmire.topomesh.topomesh.TopoMesh" href="topomesh/topomesh.html#quagmire.topomesh.topomesh.TopoMesh">TopoMesh</a></code> class (2), which in turn inherits from
the <code><a title="quagmire.mesh.pixmesh.PixMesh" href="mesh/pixmesh.html#quagmire.mesh.pixmesh.PixMesh">PixMesh</a></code>, <code><a title="quagmire.mesh.trimesh.TriMesh" href="mesh/trimesh.html#quagmire.mesh.trimesh.TriMesh">TriMesh</a></code>, or
<code><a title="quagmire.mesh.strimesh.sTriMesh" href="mesh/strimesh.html#quagmire.mesh.strimesh.sTriMesh">sTriMesh</a></code> class (3) depending on the type of mesh.</p>
<h2 id="installation">Installation</h2>
<p>Numpy and a fortran compiler, preferably <a href="https://gcc.gnu.org/wiki/GFortran">gfortran</a>, are required to install Quagmire.</p>
<ul>
<li><code>python setup.py build</code></li>
<li>If you change the fortran compiler, you may have to add the
flags <code>config_fc --fcompiler=&lt;compiler name&gt;</code> when setup.py is run
(see docs for <a href="http://docs.scipy.org/doc/numpy-dev/f2py/distutils.html">numpy.distutils</a>).</li>
<li><code>python setup.py install</code></li>
</ul>
<h2 id="dependencies">Dependencies</h2>
<p>Running this code requires the following packages to be installed. The visualisation options are required for the notebooks and are included in the docker image.</p>
<ul>
<li>Python 2.7.x and above</li>
<li>Numpy 1.9 and above</li>
<li>Scipy 0.15 and above</li>
<li><a href="http://pythonhosted.org/mpi4py/usrman/index.html">mpi4py</a></li>
<li><a href="https://pythonhosted.org/petsc4py/usrman/install.html">petsc4py</a></li>
<li><a href="https://github.com/University-of-Melbourne-Geodynamics/stripy">stripy</a></li>
<li><a href="http://docs.h5py.org/en/latest/mpi.html#building-against-parallel-hdf5">h5py</a> (optional - for saving parallel data)</li>
<li>Matplotlib (optional - for visualisation)</li>
<li>lavavu (optional - for visualisation)</li>
</ul>
<h3 id="petsc-installation">PETSc installation</h3>
<p>PETSc is used extensively via the Python frontend, petsc4py. It is required that PETSc be configured and installed on your local machine prior to using Quagmire. You can use pip or petsc to install petsc4py and its dependencies with consistent versions.</p>
<pre><code class="sh">[sudo] pip install numpy mpi4py
[sudo] pip install petsc petsc4py
</code></pre>
<p>If that fails you must compile these manually.</p>
<h3 id="hdf5-installation">HDF5 installation</h3>
<p>This is an optional installation, but it is very useful for saving data that is distributed across multiple processes. If you are compiling HDF5 from <a href="https://support.hdfgroup.org/downloads/index.html">source</a> it should be configured with the <code>--enable-parallel</code> flag:</p>
<pre><code class="sh">CC=/usr/local/mpi/bin/mpicc ./configure --enable-parallel --enable-shared --prefix=&lt;install-directory&gt;
make    # build the library
make check  # verify the correctness
make install
</code></pre>
<p>You can then point to this install directory when you install <a href="http://docs.h5py.org/en/latest/mpi.html#building-against-parallel-hdf5">h5py</a>.</p>
<h2 id="usage">Usage</h2>
<p>Quagmire is scalable in parallel. All of the python scripts in the <em>tests</em> subdirectory can be run in parallel, e.g.</p>
<pre><code class="sh">mpirun -np 4 python stream_power.py
</code></pre>
<p>where the number after the <code>-np</code> flag specifies the number of processors.</p>
<h2 id="tutorials">Tutorials</h2>
<p>Tutorials with worked examples can be found in the <em>Notebooks</em> subdirectory. These are Jupyter Notebooks that can be run locally.
We recommend installing <a href="https://ffmpeg.org/">FFmpeg</a> to create videos in some of the notebooks.</p>
<p>The topics covered in the Notebooks include:</p>
<p><strong>Meshing</strong></p>
<p>Triangulations and regular 2d arrays are included and have the same API.</p>
<ul>
<li>Square mesh</li>
<li>Elliptical mesh</li>
<li>Mesh refinement (e.g. Lloyd's mesh improvement)</li>
</ul>
<p><strong>Flow algorithms</strong></p>
<ul>
<li>Single and multiple downhill pathways</li>
<li>Accumulating flow</li>
</ul>
<p><strong>Erosion and deposition</strong></p>
<p>Operators for</p>
<ul>
<li>Long-range stream flow models</li>
<li>Short-range diffusive evolution</li>
</ul>
<p><strong>Landscape evolution</strong></p>
<p><em>Work in progress</em></p>
<ul>
<li>Explicit timestepping and numerical stability</li>
<li>Landscape equilibrium metrics</li>
<li>Basement uplift</li>
</ul>
<p><strong>Benchmarking</strong></p>
<p><em>Work in progress</em></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2016-2020 Louis Moresi, Ben Mather, Romain Beucher
# 
# This file is part of Quagmire.
#
# Quagmire is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or any later version.
# 
# Quagmire is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with Quagmire.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;
&lt;img src=&#34;https://raw.githubusercontent.com/underworldcode/quagmire/dev/docs/images/AusFlow.png&#34; style=&#34;display: block; margin: 0 auto&#34;&gt;

**Quagmire is a Python surface process framework for building erosion and deposition models on highly parallel, decomposed structured and unstructured meshes.**

Quagmire is structured into three major tiers that inherit methods and attributes from different classes:

&lt;img src=&#34;https://raw.githubusercontent.com/underworldcode/quagmire/dev/docs/images/quagmire-flowchart.png&#34; style=&#34;width: 321px; float:right&#34;&gt;

1. `SurfaceProcessMesh`
    - Calculate erosion-deposition rates
    - Landscape analysis
    - Long range flow models
2. `TopoMesh`
    - Assemble downhill connectivity matrix
    - Calculate upstream area
    - Compute slope
    - Identify flat spots, low points, high points.
3. `FlatMesh`
    - calculating spatial derivatives
    - identifying node neighbour relationships
    - interpolation / extrapolation
    - smoothing operators
    - importing and saving mesh information

The `quagmire.surfmesh.surfmesh.SurfMesh` class (1) inherits from
the `quagmire.topomesh.topomesh.TopoMesh` class (2), which in turn inherits from
the `quagmire.mesh.pixmesh.PixMesh`, `quagmire.mesh.trimesh.TriMesh`, or
`quagmire.mesh.strimesh.sTriMesh` class (3) depending on the type of mesh.


## Installation

Numpy and a fortran compiler, preferably [gfortran](https://gcc.gnu.org/wiki/GFortran), are required to install Quagmire.

- ``python setup.py build``
   - If you change the fortran compiler, you may have to add the
flags `config_fc --fcompiler=&lt;compiler name&gt;` when setup.py is run
(see docs for [numpy.distutils](http://docs.scipy.org/doc/numpy-dev/f2py/distutils.html)).
- ``python setup.py install``

## Dependencies

Running this code requires the following packages to be installed. The visualisation options are required for the notebooks and are included in the docker image.

- Python 2.7.x and above
- Numpy 1.9 and above
- Scipy 0.15 and above
- [mpi4py](http://pythonhosted.org/mpi4py/usrman/index.html)
- [petsc4py](https://pythonhosted.org/petsc4py/usrman/install.html)
- [stripy](https://github.com/University-of-Melbourne-Geodynamics/stripy)
- [h5py](http://docs.h5py.org/en/latest/mpi.html#building-against-parallel-hdf5) (optional - for saving parallel data)
- Matplotlib (optional - for visualisation)
- lavavu (optional - for visualisation)

### PETSc installation

PETSc is used extensively via the Python frontend, petsc4py. It is required that PETSc be configured and installed on your local machine prior to using Quagmire. You can use pip or petsc to install petsc4py and its dependencies with consistent versions.

```sh
[sudo] pip install numpy mpi4py
[sudo] pip install petsc petsc4py
```

If that fails you must compile these manually.

### HDF5 installation

This is an optional installation, but it is very useful for saving data that is distributed across multiple processes. If you are compiling HDF5 from [source](https://support.hdfgroup.org/downloads/index.html) it should be configured with the `--enable-parallel` flag:

```sh
CC=/usr/local/mpi/bin/mpicc ./configure --enable-parallel --enable-shared --prefix=&lt;install-directory&gt;
make    # build the library
make check  # verify the correctness
make install
```

You can then point to this install directory when you install [h5py](http://docs.h5py.org/en/latest/mpi.html#building-against-parallel-hdf5).

## Usage

Quagmire is scalable in parallel. All of the python scripts in the *tests* subdirectory can be run in parallel, e.g.

```sh
mpirun -np 4 python stream_power.py
```

where the number after the `-np` flag specifies the number of processors.

## Tutorials

Tutorials with worked examples can be found in the *Notebooks* subdirectory. These are Jupyter Notebooks that can be run locally.
We recommend installing [FFmpeg](https://ffmpeg.org/) to create videos in some of the notebooks.

The topics covered in the Notebooks include:

**Meshing**

Triangulations and regular 2d arrays are included and have the same API.

- Square mesh
- Elliptical mesh
- Mesh refinement (e.g. Lloyd&#39;s mesh improvement)

**Flow algorithms**

- Single and multiple downhill pathways
- Accumulating flow

**Erosion and deposition**

Operators for

- Long-range stream flow models
- Short-range diffusive evolution

**Landscape evolution**

_Work in progress_

- Explicit timestepping and numerical stability
- Landscape equilibrium metrics
- Basement uplift

**Benchmarking**

_Work in progress_
&#34;&#34;&#34;

from .mesh import PixMesh as _PixMesh
from .mesh import TriMesh as _TriMesh
from .mesh import sTriMesh as _sTriMesh
from petsc4py import PETSc as _PETSc
from .topomesh import TopoMesh as _TopoMeshClass

from . import documentation
from . import tools
from . import function
from . import scaling
from . import equation_systems

try:
    import lavavu
except:
    pass

_display = None

from mpi4py import MPI as _MPI
mpi_rank = _MPI.COMM_WORLD.rank
mpi_size = _MPI.COMM_WORLD.size


class _xvfb_runner(object):
    &#34;&#34;&#34;
    This class will initialise the X virtual framebuffer (Xvfb).
    Xvfb is useful on headless systems. Note that xvfb will need to be
    installed, as will pyvirtualdisplay.
    This class also manages the lifetime of the virtual display driver. When
    the object is garbage collected, the driver is stopped.
    &#34;&#34;&#34;
    def __init__(self):
        from pyvirtualdisplay import Display
        self._xvfb = Display(visible=0, size=(1600, 1200))
        self._xvfb.start()

    def __del__(self):
        if not self._xvfb is None :
            self._xvfb.stop()

import os as _os

# disable collection of data if requested
if &#34;GLUCIFER_USE_XVFB&#34; in _os.environ:
    from mpi4py import MPI as _MPI
    _comm = _MPI.COMM_WORLD
    if _comm.rank == 0:
        _display = _xvfb_runner()


known_basemesh_classes = {&#34;PixMesh&#34;  : _PixMesh, \
                          &#34;TriMesh&#34;  : _TriMesh, \
                          &#34;sTriMesh&#34; : _sTriMesh}


def _get_label(DM):
    &#34;&#34;&#34;
    Retrieves all points in the DM that is marked with a specific label.
    e.g. &#34;boundary&#34;, &#34;coarse&#34;
    &#34;&#34;&#34;

    n = DM.getNumLabels()
    success = False

    for i in range(n):
        label = DM.getLabelName(i)
        if label in known_basemesh_classes:
            success = True
            break

    if not success:
        raise NameError(&#34;Cannot identify mesh type. DM is not valid.&#34;)

    return label



def QuagMesh(DM, *args, **kwargs):
    &#34;&#34;&#34;
    Instantiates a mesh with a height and rainfall field.
    QuagMesh identifies the type of DM and builds the necessary
    data structures for landscape processing and analysis.


    Parameters
    ----------
    DM : PETSc DM object
        Either a DMDA or DMPlex object created using the meshing
        functions within `tools.meshtools`

    Returns
    -------
    QuagMesh : object
        Inherits methods and attributes from:

        - `mesh.commonmesh.CommonMesh`
        - `mesh.pixmesh.PixMesh` (if `DM` is a regularly-spaced Cartesian grid)
        - `mesh.trimesh.TriMesh` (if `DM` is an unstructred Cartesian mesh)
        - `mesh.strimesh.sTriMesh` (if `DM` is an unstructured spherical mesh)
        - `topomesh.topomesh.TopoMesh`
    &#34;&#34;&#34;

    BaseMeshType = _get_label(DM)

    if BaseMeshType in known_basemesh_classes:
        class QuagMeshClass(known_basemesh_classes[BaseMeshType], _TopoMeshClass):
            def __init__(self, dm, *args, **kwargs):
                known_basemesh_classes[BaseMeshType].__init__(self, dm, *args, **kwargs)
                _TopoMeshClass.__init__(self, *args, **kwargs)
                # super(QuagMeshClass, self).__init__(dm, *args, **kwargs)

        return QuagMeshClass(DM, *args, **kwargs)

    else:
        raise TypeError(&#34;Mesh type {:s} unknown\n\
            Known mesh types: {}&#34;.format(BaseMeshType, list(known_basemesh_classes.keys())))

    return</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="quagmire.documentation" href="documentation.html">quagmire.documentation</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="quagmire.equation_systems" href="equation_systems/index.html">quagmire.equation_systems</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="quagmire.function" href="function/index.html">quagmire.function</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="quagmire.mesh" href="mesh/index.html">quagmire.mesh</a></code></dt>
<dd>
<div class="desc"><p>The mesh module provides 3 fundamental spatial data structures â€¦</p></div>
</dd>
<dt><code class="name"><a title="quagmire.scaling" href="scaling/index.html">quagmire.scaling</a></code></dt>
<dd>
<div class="desc"><p>The scaling module provides units and scaling capabilities.</p></div>
</dd>
<dt><code class="name"><a title="quagmire.tools" href="tools/index.html">quagmire.tools</a></code></dt>
<dd>
<div class="desc"><p>Tools for creating and saving meshes</p></div>
</dd>
<dt><code class="name"><a title="quagmire.topomesh" href="topomesh/index.html">quagmire.topomesh</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="quagmire.QuagMesh"><code class="name flex">
<span>def <span class="ident">QuagMesh</span></span>(<span>DM, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Instantiates a mesh with a height and rainfall field.
QuagMesh identifies the type of DM and builds the necessary
data structures for landscape processing and analysis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>DM</code></strong> :&ensp;<code>PETSc DM object</code></dt>
<dd>Either a DMDA or DMPlex object created using the meshing
functions within <code><a title="quagmire.tools.meshtools" href="tools/meshtools.html">quagmire.tools.meshtools</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>QuagMesh</code></strong> :&ensp;<code>object</code></dt>
<dd>
<p>Inherits methods and attributes from:</p>
<ul>
<li><code><a title="quagmire.mesh.commonmesh.CommonMesh" href="mesh/commonmesh.html#quagmire.mesh.commonmesh.CommonMesh">CommonMesh</a></code></li>
<li><code><a title="quagmire.mesh.pixmesh.PixMesh" href="mesh/pixmesh.html#quagmire.mesh.pixmesh.PixMesh">PixMesh</a></code> (if <code>DM</code> is a regularly-spaced Cartesian grid)</li>
<li><code><a title="quagmire.mesh.trimesh.TriMesh" href="mesh/trimesh.html#quagmire.mesh.trimesh.TriMesh">TriMesh</a></code> (if <code>DM</code> is an unstructred Cartesian mesh)</li>
<li><code><a title="quagmire.mesh.strimesh.sTriMesh" href="mesh/strimesh.html#quagmire.mesh.strimesh.sTriMesh">sTriMesh</a></code> (if <code>DM</code> is an unstructured spherical mesh)</li>
<li><code><a title="quagmire.topomesh.topomesh.TopoMesh" href="topomesh/topomesh.html#quagmire.topomesh.topomesh.TopoMesh">TopoMesh</a></code></li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def QuagMesh(DM, *args, **kwargs):
    &#34;&#34;&#34;
    Instantiates a mesh with a height and rainfall field.
    QuagMesh identifies the type of DM and builds the necessary
    data structures for landscape processing and analysis.


    Parameters
    ----------
    DM : PETSc DM object
        Either a DMDA or DMPlex object created using the meshing
        functions within `tools.meshtools`

    Returns
    -------
    QuagMesh : object
        Inherits methods and attributes from:

        - `mesh.commonmesh.CommonMesh`
        - `mesh.pixmesh.PixMesh` (if `DM` is a regularly-spaced Cartesian grid)
        - `mesh.trimesh.TriMesh` (if `DM` is an unstructred Cartesian mesh)
        - `mesh.strimesh.sTriMesh` (if `DM` is an unstructured spherical mesh)
        - `topomesh.topomesh.TopoMesh`
    &#34;&#34;&#34;

    BaseMeshType = _get_label(DM)

    if BaseMeshType in known_basemesh_classes:
        class QuagMeshClass(known_basemesh_classes[BaseMeshType], _TopoMeshClass):
            def __init__(self, dm, *args, **kwargs):
                known_basemesh_classes[BaseMeshType].__init__(self, dm, *args, **kwargs)
                _TopoMeshClass.__init__(self, *args, **kwargs)
                # super(QuagMeshClass, self).__init__(dm, *args, **kwargs)

        return QuagMeshClass(DM, *args, **kwargs)

    else:
        raise TypeError(&#34;Mesh type {:s} unknown\n\
            Known mesh types: {}&#34;.format(BaseMeshType, list(known_basemesh_classes.keys())))

    return</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#dependencies">Dependencies</a><ul>
<li><a href="#petsc-installation">PETSc installation</a></li>
<li><a href="#hdf5-installation">HDF5 installation</a></li>
</ul>
</li>
<li><a href="#usage">Usage</a></li>
<li><a href="#tutorials">Tutorials</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="quagmire.documentation" href="documentation.html">quagmire.documentation</a></code></li>
<li><code><a title="quagmire.equation_systems" href="equation_systems/index.html">quagmire.equation_systems</a></code></li>
<li><code><a title="quagmire.function" href="function/index.html">quagmire.function</a></code></li>
<li><code><a title="quagmire.mesh" href="mesh/index.html">quagmire.mesh</a></code></li>
<li><code><a title="quagmire.scaling" href="scaling/index.html">quagmire.scaling</a></code></li>
<li><code><a title="quagmire.tools" href="tools/index.html">quagmire.tools</a></code></li>
<li><code><a title="quagmire.topomesh" href="topomesh/index.html">quagmire.topomesh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="quagmire.QuagMesh" href="#quagmire.QuagMesh">QuagMesh</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>