<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>quagmire.function.function_classes API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>quagmire.function.function_classes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2016-2020 Louis Moresi, Ben Mather, Romain Beucher
# 
# This file is part of Quagmire.
# 
# Quagmire is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or any later version.
# 
# Quagmire is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with Quagmire.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

import numpy as np
import quagmire


class LazyEvaluation(object):

    __count = 0

    @classmethod
    def _count(cls):
        LazyEvaluation.__count += 1
        return LazyEvaluation.__count

    @property
    def id(self):
        return self.__id


    def __init__(self, mesh=None):
        &#34;&#34;&#34;Lazy evaluation of mesh variables / parameters
           If no mesh is provided then no gradient function can be implemented&#34;&#34;&#34;

        self.__id = &#34;q_fn_{}&#34;.format(self._count())

        self.description = &#34;&#34;
        self._mesh = mesh
        self.mesh_data = False
        self.dependency_list = set([self.id])

        return

    def __repr__(self):
        return(&#34;quagmire.fn: {}&#34;.format(self.description))

    def evaluate(self, *args, **kwargs):
        raise(NotImplementedError)

    def fn_gradient(self, dirn=None, mesh=None):
        &#34;&#34;&#34;
        The generic mechanism for obtaining the gradient of a lazy variable is
        to evaluate the values on the mesh at the time in question and use the mesh gradient
        operators to compute the new values.

        Sub classes may have more efficient approaches. MeshVariables have
        stored data and don&#39;t need to evaluate values. Parameters have Gradients
        that are identically zero ... etc
        &#34;&#34;&#34;

        import quagmire

        if self._mesh is None and mesh is None:
            raise RuntimeError(&#34;fn_gradient is a numerical differentiation routine based on derivatives of a fitted spline function on a mesh. The function {} has no associated mesh. To obtain *numerical* derivatives of this function, you can provide a mesh to the gradient function. The usual reason for this error is that your function is not based upon mesh variables and can, perhaps, be differentiated without resort to interpolating splines. &#34;.format(self.__repr__()))


        elif self._mesh is not None:
            diff_mesh = self._mesh
        else:
            quagmire.mesh.check_object_is_a_q_mesh_and_raise(mesh)
            diff_mesh = mesh

        ndim = np.shape(diff_mesh.data)[1]

        def new_fn_x(*args, **kwargs):
            local_array = self.evaluate(diff_mesh)
            df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
            dx = df_tuple[0]

            if len(args) == 1 and args[0] == diff_mesh:
                return dx

            elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
                mesh = args[0]
                return diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=dx, **kwargs)
            elif len(args) &gt; 1:
                xi = np.atleast_1d(args[0])
                yi = np.atleast_1d(args[1])
                i, e = diff_mesh.interpolate(xi, yi, zdata=dx, **kwargs)
                return i
            else:
                err_msg = &#34;Invalid number of arguments\n&#34;
                err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
                raise ValueError(err_msg)

        def new_fn_y(*args, **kwargs):
            local_array = self.evaluate(diff_mesh)
            df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
            dy = df_tuple[1]

            if len(args) == 1 and args[0] == diff_mesh:
                return dy
            elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
                mesh = args[0]
                return diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=dy, **kwargs)
            elif len(args) &gt; 1:
                xi = np.atleast_1d(args[0])  # .resize(-1,1)
                yi = np.atleast_1d(args[1])  # .resize(-1,1)
                i, e = diff_mesh.interpolate(xi, yi, zdata=dy, **kwargs)
                return i
            else:
                err_msg = &#34;Invalid number of arguments\n&#34;
                err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
                raise ValueError(err_msg)

        def new_fn_z(*args, **kwargs):
            local_array = self.evaluate(diff_mesh)
            df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
            dz = df_tuple[2]

            if len(args) == 1 and args[0] == diff_mesh:
                return dz
            elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
                mesh = args[0]
                return diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=dz, **kwargs)
            elif len(args) &gt; 1:
                xi = np.atleast_1d(args[0])  # .resize(-1,1)
                yi = np.atleast_1d(args[1])  # .resize(-1,1)
                i, e = diff_mesh.interpolate(xi, yi, zdata=dz, **kwargs)
                return i
            else:
                err_msg = &#34;Invalid number of arguments\n&#34;
                err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
                raise ValueError(err_msg)

        # Should this be made into a vector mesh variable ?
        def new_fn_grad(*args, **kwargs):
            local_array = self.evaluate(diff_mesh)
            df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
            ndim = len(df_tuple)

            if len(args) == 1 and args[0] == diff_mesh:
                return df_tuple
            elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
                mesh = args[0]
                df_interp = []
                for df in df_tuple:
                    result = diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=df, **kwargs)
                    df_interp.append(result)
                return df_interp
            elif len(args) &gt; 1:
                xi = np.atleast_1d(args[0])  # .resize(-1,1)
                yi = np.atleast_1d(args[1])  # .resize(-1,1)
                df_interp = []
                for df in df_tuple:
                    i, e = diff_mesh.interpolate(xi, yi, zdata=df, **kwargs)
                    df_interp.append(i)
                return df_interp
            else:
                err_msg = &#34;Invalid number of arguments\n&#34;
                err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
                raise ValueError(err_msg)

        newLazyFn_dx = LazyEvaluation(mesh=diff_mesh)
        newLazyFn_dx.evaluate = new_fn_x
        newLazyFn_dx.description = &#34;d({})/dX&#34;.format(self.description)
        newLazyFn_dy = LazyEvaluation(mesh=diff_mesh)
        newLazyFn_dy.evaluate = new_fn_y
        newLazyFn_dy.description = &#34;d({})/dY&#34;.format(self.description)
        newLazyFn_dz = LazyEvaluation(mesh=diff_mesh)
        newLazyFn_dz.evaluate = new_fn_z
        newLazyFn_dz.description = &#34;d({})/dZ&#34;.format(self.description)

        fn_dir = [newLazyFn_dx, newLazyFn_dy, newLazyFn_dz][0:ndim]

        if dirn is None:
            # return a vector mesh variable ?
            return fn_dir
        else:
            return fn_dir[dirn]


    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        self._description = &#34;{}&#34;.format(value)

## Arithmetic operations

    def __mul__(self, other):
        mesh = self._mesh
        if mesh == None:
            mesh = other._mesh
        newLazyFn = LazyEvaluation(mesh=mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : self.evaluate(*args, **kwargs) * other.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;({})*({})&#34;.format(self.description, other.description)
        newLazyFn.dependency_list |= self.dependency_list | other.dependency_list
        return newLazyFn

    def __add__(self, other):
        mesh = self._mesh
        if mesh == None:
            mesh = other._mesh
        newLazyFn = LazyEvaluation(mesh=mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : self.evaluate(*args, **kwargs) + other.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;({})+({})&#34;.format(self.description, other.description)
        newLazyFn.dependency_list |= self.dependency_list | other.dependency_list

        return newLazyFn

    def __truediv__(self, other):
        mesh = self._mesh
        if mesh == None:
            mesh = other._mesh
        newLazyFn = LazyEvaluation(mesh=mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : self.evaluate(*args, **kwargs) / other.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;({})/({})&#34;.format(self.description, other.description)
        newLazyFn.dependency_list |= self.dependency_list | other.dependency_list

        return newLazyFn

    def __sub__(self, other):
        mesh = self._mesh
        if mesh == None:
            mesh = other._mesh
        newLazyFn = LazyEvaluation(mesh=mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : self.evaluate(*args, **kwargs) - other.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;({})-({})&#34;.format(self.description, other.description)
        newLazyFn.dependency_list |= self.dependency_list | other.dependency_list

        return newLazyFn

    def __neg__(self):
        newLazyFn = LazyEvaluation(mesh=self._mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : -1.0 * self.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;-({})&#34;.format(self.description)
        newLazyFn.dependency_list |= self.dependency_list

        return newLazyFn

    def __pow__(self, exponent):
        if isinstance(exponent, (float, int)):
            exponent = parameter(float(exponent))
        newLazyFn = LazyEvaluation(mesh=self._mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : np.power(self.evaluate(*args, **kwargs), exponent.evaluate(*args, **kwargs))
        newLazyFn.description = &#34;({})**({})&#34;.format(self.description, exponent.description)
        newLazyFn.dependency_list |= self.dependency_list | exponent.dependency_list

        return newLazyFn


## need a fn.coord to extract (x or y) ??

# class variable(LazyEvaluation):
#     &#34;&#34;&#34;Lazy evaluation of Mesh Variables&#34;&#34;&#34;
#     def __init__(self, meshVariable):
#         super(variable, self).__init__()
#         self._mesh_variable = meshVariable
#         self.description = meshVariable._name
#         return
#
#     def evaluate(self, *args, coords=None):
#         return self._mesh_variable.evaluate(*args)

class parameter(LazyEvaluation):
    &#34;&#34;&#34;Floating point parameter / coefficient for lazy evaluation of functions&#34;&#34;&#34;

    def __init__(self, value):
        super(parameter, self).__init__()
        self.value = value
        return

    def fn_gradient(self, dirn=None):
        &#34;&#34;&#34;Gradients information is not provided by default for lazy evaluation objects:
           it is necessary to implement the gradient method&#34;&#34;&#34;

        px = parameter(0.0)
        px.description = &#34;d({})/dX===0.0&#34;.format(self.description)
        py = parameter(0.0)
        py.description = &#34;d({})/dY===0.0&#34;.format(self.description)
        pz = parameter(0.0)
        pz.description = &#34;d({})/dZ===0.0&#34;.format(self.description)

        p = [px, py, pz]

        if dirn is None:
            # not sure about dimensions here, a parameter is always 1-d so it should
            # always return the same derivative
            return px
        else:
            return p[dirn]

    def __call__(self, value=None):
        &#34;&#34;&#34;Set value (X) of this parameter (equivalent to Parameter.value=X)&#34;&#34;&#34;
        if value is not None:
            self.value = value
        return

    def __repr__(self):
        return(&#34;quagmire lazy evaluation parameter: {}&#34;.format(self._value))

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        self._value = float(value)
        self.description = &#34;{}&#34;.format(self._value)

    def evaluate(self, *args, **kwargs):

        if len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
            mesh = args[0]
            return self.value * np.ones(mesh.npoints)

        elif any(args):
            xi = np.atleast_1d(args[0])
            yi = np.atleast_1d(args[1])

            return self.value * np.ones_like(xi)

        else:
            return self.value</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="quagmire.function.function_classes.LazyEvaluation"><code class="flex name class">
<span>class <span class="ident">LazyEvaluation</span></span>
<span>(</span><span>mesh=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Lazy evaluation of mesh variables / parameters
If no mesh is provided then no gradient function can be implemented</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LazyEvaluation(object):

    __count = 0

    @classmethod
    def _count(cls):
        LazyEvaluation.__count += 1
        return LazyEvaluation.__count

    @property
    def id(self):
        return self.__id


    def __init__(self, mesh=None):
        &#34;&#34;&#34;Lazy evaluation of mesh variables / parameters
           If no mesh is provided then no gradient function can be implemented&#34;&#34;&#34;

        self.__id = &#34;q_fn_{}&#34;.format(self._count())

        self.description = &#34;&#34;
        self._mesh = mesh
        self.mesh_data = False
        self.dependency_list = set([self.id])

        return

    def __repr__(self):
        return(&#34;quagmire.fn: {}&#34;.format(self.description))

    def evaluate(self, *args, **kwargs):
        raise(NotImplementedError)

    def fn_gradient(self, dirn=None, mesh=None):
        &#34;&#34;&#34;
        The generic mechanism for obtaining the gradient of a lazy variable is
        to evaluate the values on the mesh at the time in question and use the mesh gradient
        operators to compute the new values.

        Sub classes may have more efficient approaches. MeshVariables have
        stored data and don&#39;t need to evaluate values. Parameters have Gradients
        that are identically zero ... etc
        &#34;&#34;&#34;

        import quagmire

        if self._mesh is None and mesh is None:
            raise RuntimeError(&#34;fn_gradient is a numerical differentiation routine based on derivatives of a fitted spline function on a mesh. The function {} has no associated mesh. To obtain *numerical* derivatives of this function, you can provide a mesh to the gradient function. The usual reason for this error is that your function is not based upon mesh variables and can, perhaps, be differentiated without resort to interpolating splines. &#34;.format(self.__repr__()))


        elif self._mesh is not None:
            diff_mesh = self._mesh
        else:
            quagmire.mesh.check_object_is_a_q_mesh_and_raise(mesh)
            diff_mesh = mesh

        ndim = np.shape(diff_mesh.data)[1]

        def new_fn_x(*args, **kwargs):
            local_array = self.evaluate(diff_mesh)
            df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
            dx = df_tuple[0]

            if len(args) == 1 and args[0] == diff_mesh:
                return dx

            elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
                mesh = args[0]
                return diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=dx, **kwargs)
            elif len(args) &gt; 1:
                xi = np.atleast_1d(args[0])
                yi = np.atleast_1d(args[1])
                i, e = diff_mesh.interpolate(xi, yi, zdata=dx, **kwargs)
                return i
            else:
                err_msg = &#34;Invalid number of arguments\n&#34;
                err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
                raise ValueError(err_msg)

        def new_fn_y(*args, **kwargs):
            local_array = self.evaluate(diff_mesh)
            df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
            dy = df_tuple[1]

            if len(args) == 1 and args[0] == diff_mesh:
                return dy
            elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
                mesh = args[0]
                return diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=dy, **kwargs)
            elif len(args) &gt; 1:
                xi = np.atleast_1d(args[0])  # .resize(-1,1)
                yi = np.atleast_1d(args[1])  # .resize(-1,1)
                i, e = diff_mesh.interpolate(xi, yi, zdata=dy, **kwargs)
                return i
            else:
                err_msg = &#34;Invalid number of arguments\n&#34;
                err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
                raise ValueError(err_msg)

        def new_fn_z(*args, **kwargs):
            local_array = self.evaluate(diff_mesh)
            df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
            dz = df_tuple[2]

            if len(args) == 1 and args[0] == diff_mesh:
                return dz
            elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
                mesh = args[0]
                return diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=dz, **kwargs)
            elif len(args) &gt; 1:
                xi = np.atleast_1d(args[0])  # .resize(-1,1)
                yi = np.atleast_1d(args[1])  # .resize(-1,1)
                i, e = diff_mesh.interpolate(xi, yi, zdata=dz, **kwargs)
                return i
            else:
                err_msg = &#34;Invalid number of arguments\n&#34;
                err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
                raise ValueError(err_msg)

        # Should this be made into a vector mesh variable ?
        def new_fn_grad(*args, **kwargs):
            local_array = self.evaluate(diff_mesh)
            df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
            ndim = len(df_tuple)

            if len(args) == 1 and args[0] == diff_mesh:
                return df_tuple
            elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
                mesh = args[0]
                df_interp = []
                for df in df_tuple:
                    result = diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=df, **kwargs)
                    df_interp.append(result)
                return df_interp
            elif len(args) &gt; 1:
                xi = np.atleast_1d(args[0])  # .resize(-1,1)
                yi = np.atleast_1d(args[1])  # .resize(-1,1)
                df_interp = []
                for df in df_tuple:
                    i, e = diff_mesh.interpolate(xi, yi, zdata=df, **kwargs)
                    df_interp.append(i)
                return df_interp
            else:
                err_msg = &#34;Invalid number of arguments\n&#34;
                err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
                raise ValueError(err_msg)

        newLazyFn_dx = LazyEvaluation(mesh=diff_mesh)
        newLazyFn_dx.evaluate = new_fn_x
        newLazyFn_dx.description = &#34;d({})/dX&#34;.format(self.description)
        newLazyFn_dy = LazyEvaluation(mesh=diff_mesh)
        newLazyFn_dy.evaluate = new_fn_y
        newLazyFn_dy.description = &#34;d({})/dY&#34;.format(self.description)
        newLazyFn_dz = LazyEvaluation(mesh=diff_mesh)
        newLazyFn_dz.evaluate = new_fn_z
        newLazyFn_dz.description = &#34;d({})/dZ&#34;.format(self.description)

        fn_dir = [newLazyFn_dx, newLazyFn_dy, newLazyFn_dz][0:ndim]

        if dirn is None:
            # return a vector mesh variable ?
            return fn_dir
        else:
            return fn_dir[dirn]


    @property
    def description(self):
        return self._description

    @description.setter
    def description(self, value):
        self._description = &#34;{}&#34;.format(value)

## Arithmetic operations

    def __mul__(self, other):
        mesh = self._mesh
        if mesh == None:
            mesh = other._mesh
        newLazyFn = LazyEvaluation(mesh=mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : self.evaluate(*args, **kwargs) * other.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;({})*({})&#34;.format(self.description, other.description)
        newLazyFn.dependency_list |= self.dependency_list | other.dependency_list
        return newLazyFn

    def __add__(self, other):
        mesh = self._mesh
        if mesh == None:
            mesh = other._mesh
        newLazyFn = LazyEvaluation(mesh=mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : self.evaluate(*args, **kwargs) + other.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;({})+({})&#34;.format(self.description, other.description)
        newLazyFn.dependency_list |= self.dependency_list | other.dependency_list

        return newLazyFn

    def __truediv__(self, other):
        mesh = self._mesh
        if mesh == None:
            mesh = other._mesh
        newLazyFn = LazyEvaluation(mesh=mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : self.evaluate(*args, **kwargs) / other.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;({})/({})&#34;.format(self.description, other.description)
        newLazyFn.dependency_list |= self.dependency_list | other.dependency_list

        return newLazyFn

    def __sub__(self, other):
        mesh = self._mesh
        if mesh == None:
            mesh = other._mesh
        newLazyFn = LazyEvaluation(mesh=mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : self.evaluate(*args, **kwargs) - other.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;({})-({})&#34;.format(self.description, other.description)
        newLazyFn.dependency_list |= self.dependency_list | other.dependency_list

        return newLazyFn

    def __neg__(self):
        newLazyFn = LazyEvaluation(mesh=self._mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : -1.0 * self.evaluate(*args, **kwargs)
        newLazyFn.description = &#34;-({})&#34;.format(self.description)
        newLazyFn.dependency_list |= self.dependency_list

        return newLazyFn

    def __pow__(self, exponent):
        if isinstance(exponent, (float, int)):
            exponent = parameter(float(exponent))
        newLazyFn = LazyEvaluation(mesh=self._mesh)
        newLazyFn.evaluate = lambda *args, **kwargs : np.power(self.evaluate(*args, **kwargs), exponent.evaluate(*args, **kwargs))
        newLazyFn.description = &#34;({})**({})&#34;.format(self.description, exponent.description)
        newLazyFn.dependency_list |= self.dependency_list | exponent.dependency_list

        return newLazyFn</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="quagmire.function.function_classes.parameter" href="#quagmire.function.function_classes.parameter">parameter</a></li>
<li><a title="quagmire.mesh.basemesh.MeshVariable" href="../mesh/basemesh.html#quagmire.mesh.basemesh.MeshVariable">MeshVariable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="quagmire.function.function_classes.LazyEvaluation.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self):
    return self._description</code></pre>
</details>
</dd>
<dt id="quagmire.function.function_classes.LazyEvaluation.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    return self.__id</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quagmire.function.function_classes.LazyEvaluation.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, *args, **kwargs):
    raise(NotImplementedError)</code></pre>
</details>
</dd>
<dt id="quagmire.function.function_classes.LazyEvaluation.fn_gradient"><code class="name flex">
<span>def <span class="ident">fn_gradient</span></span>(<span>self, dirn=None, mesh=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The generic mechanism for obtaining the gradient of a lazy variable is
to evaluate the values on the mesh at the time in question and use the mesh gradient
operators to compute the new values.</p>
<p>Sub classes may have more efficient approaches. MeshVariables have
stored data and don't need to evaluate values. Parameters have Gradients
that are identically zero &hellip; etc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fn_gradient(self, dirn=None, mesh=None):
    &#34;&#34;&#34;
    The generic mechanism for obtaining the gradient of a lazy variable is
    to evaluate the values on the mesh at the time in question and use the mesh gradient
    operators to compute the new values.

    Sub classes may have more efficient approaches. MeshVariables have
    stored data and don&#39;t need to evaluate values. Parameters have Gradients
    that are identically zero ... etc
    &#34;&#34;&#34;

    import quagmire

    if self._mesh is None and mesh is None:
        raise RuntimeError(&#34;fn_gradient is a numerical differentiation routine based on derivatives of a fitted spline function on a mesh. The function {} has no associated mesh. To obtain *numerical* derivatives of this function, you can provide a mesh to the gradient function. The usual reason for this error is that your function is not based upon mesh variables and can, perhaps, be differentiated without resort to interpolating splines. &#34;.format(self.__repr__()))


    elif self._mesh is not None:
        diff_mesh = self._mesh
    else:
        quagmire.mesh.check_object_is_a_q_mesh_and_raise(mesh)
        diff_mesh = mesh

    ndim = np.shape(diff_mesh.data)[1]

    def new_fn_x(*args, **kwargs):
        local_array = self.evaluate(diff_mesh)
        df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
        dx = df_tuple[0]

        if len(args) == 1 and args[0] == diff_mesh:
            return dx

        elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
            mesh = args[0]
            return diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=dx, **kwargs)
        elif len(args) &gt; 1:
            xi = np.atleast_1d(args[0])
            yi = np.atleast_1d(args[1])
            i, e = diff_mesh.interpolate(xi, yi, zdata=dx, **kwargs)
            return i
        else:
            err_msg = &#34;Invalid number of arguments\n&#34;
            err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
            raise ValueError(err_msg)

    def new_fn_y(*args, **kwargs):
        local_array = self.evaluate(diff_mesh)
        df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
        dy = df_tuple[1]

        if len(args) == 1 and args[0] == diff_mesh:
            return dy
        elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
            mesh = args[0]
            return diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=dy, **kwargs)
        elif len(args) &gt; 1:
            xi = np.atleast_1d(args[0])  # .resize(-1,1)
            yi = np.atleast_1d(args[1])  # .resize(-1,1)
            i, e = diff_mesh.interpolate(xi, yi, zdata=dy, **kwargs)
            return i
        else:
            err_msg = &#34;Invalid number of arguments\n&#34;
            err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
            raise ValueError(err_msg)

    def new_fn_z(*args, **kwargs):
        local_array = self.evaluate(diff_mesh)
        df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
        dz = df_tuple[2]

        if len(args) == 1 and args[0] == diff_mesh:
            return dz
        elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
            mesh = args[0]
            return diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=dz, **kwargs)
        elif len(args) &gt; 1:
            xi = np.atleast_1d(args[0])  # .resize(-1,1)
            yi = np.atleast_1d(args[1])  # .resize(-1,1)
            i, e = diff_mesh.interpolate(xi, yi, zdata=dz, **kwargs)
            return i
        else:
            err_msg = &#34;Invalid number of arguments\n&#34;
            err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
            raise ValueError(err_msg)

    # Should this be made into a vector mesh variable ?
    def new_fn_grad(*args, **kwargs):
        local_array = self.evaluate(diff_mesh)
        df_tuple = diff_mesh.derivative_grad(local_array, nit=10, tol=1e-8)
        ndim = len(df_tuple)

        if len(args) == 1 and args[0] == diff_mesh:
            return df_tuple
        elif len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
            mesh = args[0]
            df_interp = []
            for df in df_tuple:
                result = diff_mesh.interpolate(mesh.coords[:,0], mesh.coords[:,1], zdata=df, **kwargs)
                df_interp.append(result)
            return df_interp
        elif len(args) &gt; 1:
            xi = np.atleast_1d(args[0])  # .resize(-1,1)
            yi = np.atleast_1d(args[1])  # .resize(-1,1)
            df_interp = []
            for df in df_tuple:
                i, e = diff_mesh.interpolate(xi, yi, zdata=df, **kwargs)
                df_interp.append(i)
            return df_interp
        else:
            err_msg = &#34;Invalid number of arguments\n&#34;
            err_msg += &#34;Input a valid mesh or coordinates in x,y directions&#34;
            raise ValueError(err_msg)

    newLazyFn_dx = LazyEvaluation(mesh=diff_mesh)
    newLazyFn_dx.evaluate = new_fn_x
    newLazyFn_dx.description = &#34;d({})/dX&#34;.format(self.description)
    newLazyFn_dy = LazyEvaluation(mesh=diff_mesh)
    newLazyFn_dy.evaluate = new_fn_y
    newLazyFn_dy.description = &#34;d({})/dY&#34;.format(self.description)
    newLazyFn_dz = LazyEvaluation(mesh=diff_mesh)
    newLazyFn_dz.evaluate = new_fn_z
    newLazyFn_dz.description = &#34;d({})/dZ&#34;.format(self.description)

    fn_dir = [newLazyFn_dx, newLazyFn_dy, newLazyFn_dz][0:ndim]

    if dirn is None:
        # return a vector mesh variable ?
        return fn_dir
    else:
        return fn_dir[dirn]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="quagmire.function.function_classes.parameter"><code class="flex name class">
<span>class <span class="ident">parameter</span></span>
<span>(</span><span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Floating point parameter / coefficient for lazy evaluation of functions</p>
<p>Lazy evaluation of mesh variables / parameters
If no mesh is provided then no gradient function can be implemented</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class parameter(LazyEvaluation):
    &#34;&#34;&#34;Floating point parameter / coefficient for lazy evaluation of functions&#34;&#34;&#34;

    def __init__(self, value):
        super(parameter, self).__init__()
        self.value = value
        return

    def fn_gradient(self, dirn=None):
        &#34;&#34;&#34;Gradients information is not provided by default for lazy evaluation objects:
           it is necessary to implement the gradient method&#34;&#34;&#34;

        px = parameter(0.0)
        px.description = &#34;d({})/dX===0.0&#34;.format(self.description)
        py = parameter(0.0)
        py.description = &#34;d({})/dY===0.0&#34;.format(self.description)
        pz = parameter(0.0)
        pz.description = &#34;d({})/dZ===0.0&#34;.format(self.description)

        p = [px, py, pz]

        if dirn is None:
            # not sure about dimensions here, a parameter is always 1-d so it should
            # always return the same derivative
            return px
        else:
            return p[dirn]

    def __call__(self, value=None):
        &#34;&#34;&#34;Set value (X) of this parameter (equivalent to Parameter.value=X)&#34;&#34;&#34;
        if value is not None:
            self.value = value
        return

    def __repr__(self):
        return(&#34;quagmire lazy evaluation parameter: {}&#34;.format(self._value))

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        self._value = float(value)
        self.description = &#34;{}&#34;.format(self._value)

    def evaluate(self, *args, **kwargs):

        if len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
            mesh = args[0]
            return self.value * np.ones(mesh.npoints)

        elif any(args):
            xi = np.atleast_1d(args[0])
            yi = np.atleast_1d(args[1])

            return self.value * np.ones_like(xi)

        else:
            return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quagmire.function.function_classes.LazyEvaluation" href="#quagmire.function.function_classes.LazyEvaluation">LazyEvaluation</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="quagmire.function.function_classes.parameter.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    return self._value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quagmire.function.function_classes.parameter.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, *args, **kwargs):

    if len(args) == 1 and quagmire.mesh.check_object_is_a_q_mesh_and_raise(args[0]):
        mesh = args[0]
        return self.value * np.ones(mesh.npoints)

    elif any(args):
        xi = np.atleast_1d(args[0])
        yi = np.atleast_1d(args[1])

        return self.value * np.ones_like(xi)

    else:
        return self.value</code></pre>
</details>
</dd>
<dt id="quagmire.function.function_classes.parameter.fn_gradient"><code class="name flex">
<span>def <span class="ident">fn_gradient</span></span>(<span>self, dirn=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gradients information is not provided by default for lazy evaluation objects:
it is necessary to implement the gradient method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fn_gradient(self, dirn=None):
    &#34;&#34;&#34;Gradients information is not provided by default for lazy evaluation objects:
       it is necessary to implement the gradient method&#34;&#34;&#34;

    px = parameter(0.0)
    px.description = &#34;d({})/dX===0.0&#34;.format(self.description)
    py = parameter(0.0)
    py.description = &#34;d({})/dY===0.0&#34;.format(self.description)
    pz = parameter(0.0)
    pz.description = &#34;d({})/dZ===0.0&#34;.format(self.description)

    p = [px, py, pz]

    if dirn is None:
        # not sure about dimensions here, a parameter is always 1-d so it should
        # always return the same derivative
        return px
    else:
        return p[dirn]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="quagmire.function" href="index.html">quagmire.function</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="quagmire.function.function_classes.LazyEvaluation" href="#quagmire.function.function_classes.LazyEvaluation">LazyEvaluation</a></code></h4>
<ul class="">
<li><code><a title="quagmire.function.function_classes.LazyEvaluation.description" href="#quagmire.function.function_classes.LazyEvaluation.description">description</a></code></li>
<li><code><a title="quagmire.function.function_classes.LazyEvaluation.evaluate" href="#quagmire.function.function_classes.LazyEvaluation.evaluate">evaluate</a></code></li>
<li><code><a title="quagmire.function.function_classes.LazyEvaluation.fn_gradient" href="#quagmire.function.function_classes.LazyEvaluation.fn_gradient">fn_gradient</a></code></li>
<li><code><a title="quagmire.function.function_classes.LazyEvaluation.id" href="#quagmire.function.function_classes.LazyEvaluation.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quagmire.function.function_classes.parameter" href="#quagmire.function.function_classes.parameter">parameter</a></code></h4>
<ul class="">
<li><code><a title="quagmire.function.function_classes.parameter.evaluate" href="#quagmire.function.function_classes.parameter.evaluate">evaluate</a></code></li>
<li><code><a title="quagmire.function.function_classes.parameter.fn_gradient" href="#quagmire.function.function_classes.parameter.fn_gradient">fn_gradient</a></code></li>
<li><code><a title="quagmire.function.function_classes.parameter.value" href="#quagmire.function.function_classes.parameter.value">value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>